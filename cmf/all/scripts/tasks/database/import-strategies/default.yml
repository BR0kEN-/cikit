# Used variables:
# - become_name: the name of user, who triggered this script.
# - become_home: the home directory of user, who triggered this script.
#
# Used built-in variables:
# - hostvars: list of data for all defined hosts.
---
- include_tasks: ../../get-hostname.yml name="{{ item.value.source.from }}"

- name: Set remote host
  set_fact:
    dump_remote_path: "{{ item.value.source.dir | default(dump_local_path | dirname) }}/{{ item.value.source.db }}.gz"

- name: Check for remote snapshot
  stat:
    path: "{{ dump_remote_path }}"
  register: remote_dump
  delegate_to: "{{ item.value.source.from }}"

# The "mysql_db" module isn't used because the "mysqldb" module for Python might not be installed on remote.
- name: Create snapshot
  shell: >
    ssh {{ hostname_ssh.args }} {{ hostname_ssh.host }} "mysqldump -P{{ item.value.source.port | default(3306) }} -h{{ item.value.source.host | default('127.0.0.1') }} -u{{ item.value.source.user | default(mysql.user) }} -p{{ item.value.source.pass | default(mysql.pass) }} {{ item.value.source.db }} | gzip -c > {{ dump_remote_path }}"
  register: dump_created
  when: not remote_dump.stat.exists

# @todo The "synchronize" isn't work with Ansible 2.2.2.0 with "delegate_to" parameter.
# Instead of correct SSH credentials for remote it take your WAN IP. Do not be shy test
# this as often as possible, because Ansible is pretty fast developing.
- name: Fetch snapshot
  shell: "rsync --delay-updates -F --compress --archive --rsh 'ssh {{ hostname_ssh.args }}' {{ hostname_ssh.host }}:{{ dump_remote_path }} {{ dump_local_path }}"
  when: remote_dump.stat.exists or dump_created.changed
