const speakeasy = require('speakeasy');
const RuntimeError = require('../error/RuntimeError');

/**
 * Destroy old and generate new "access" and "refresh" tokens.
 *
 * @param {Object} app
 *   The application's object.
 * @param {String} userId
 *   The ID of a user.
 *
 * @return {Promise}
 */
async function generateTokens(app, userId) {
  const crypto = app.get('crypto');
  const [AccessToken, RefreshToken] = await Promise.all(['AccessToken', 'RefreshToken'].map(async name => {
    const object = app.get(name);
    await object.remove({userId});

    return await new object({userId, token: crypto.randomBytes(32).toString('hex')}).save();
  }));

  return {
    token_type: 'Bearer',
    expires_in: app.get('config').get('security:tokenLife'),
    access_token: AccessToken.toString(),
    refresh_token: RefreshToken.toString(),
  };
}

/**
 * Generates the TOTP secret key based on the config.
 *
 * @param {Object} totp
 * @param {String} totp.type
 * @param {Number} totp.length
 * @param {String} totp.issuer
 *
 * @return {Boolean}
 *
 * @link https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
 */
function generateTotpSecret(totp) {
  return speakeasy.generateSecret({length: totp.length, otpauth_url: false})[totp.type];
}

/**
 * Checks whether TOTP token is valid.
 *
 * @param {Object} totp
 * @param {String} totp.type
 * @param {Number} totp.length
 * @param {String} totp.issuer
 * @param {String} secret
 *   The secret key, generated for the authenticating app.
 * @param {String} token
 *   The token, generated by authenticating app, that needs to be verified.
 *
 * @return {Boolean}
 */
function isTotpTokenValid(totp, secret, token) {
  return speakeasy.totp.verify({secret, token, encoding: totp.type});
}

/**
 * Checks whether the user is authorized and belongs to requested group.
 *
 * @param {Object} app
 *   The application's object.
 * @param {String} requestedGroup
 *   The name of a group, the route require the user to have.
 *
 * @return {Function}
 *   Express.js middleware.
 */
function ensureAuthorizedAccess(app, requestedGroup) {
  const verifier = (config, requestedGroup, request, response, next) => {
    if (!request.user) {
      throw new RuntimeError('Unauthorized', 401, config.get('errors:user_unauthorized'));
    }

    if (!request.user.group) {
      throw new RuntimeError('The user does not belong to a group', 401, config.get('errors:user_ungrouped'));
    }

    const userGroups = config.get('security:user:groups');

    if (!userGroups.hasOwnProperty(request.user.group)) {
      throw new RuntimeError('The user is in an unknown group', 401, config.get('errors:user_group_unknown'));
    }

    if (!userGroups.hasOwnProperty(requestedGroup)) {
      throw new RuntimeError('Route requested an access for the unknown group', 401, config.get('errors:route_group_unknown'));
    }

    if (
      // A user belongs to the requested group.
      requestedGroup === request.user.group ||
      // A user's group inherits the requested group.
      userGroups[requestedGroup].indexOf(request.user.group) !== -1
    ) {
      return next();
    }

    throw new RuntimeError('Access denied', 403, config.get('errors:route_access_denied'));
  };

  return verifier.bind(undefined, app.get('config'), requestedGroup);
}

module.exports = {
  generateTokens,
  generateTotpSecret,
  isTotpTokenValid,
  ensureAuthorizedAccess,
};
