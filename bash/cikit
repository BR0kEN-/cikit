#!/usr/bin/env bash

# The internal version of CIKit.
VERSION="0.0.1"
COMMAND="ansible-playbook"
# List of parameters for "ansible-playbook" command.
PARAMS=""
# JSON formatted "--extra-vars" options.
VARS=""

RED="\e[0;31m"
GREEN="\e[0;32m"
YELLOW="\e[0;33m"
BLUE="\e[0;34m"
PINK="\e[0;35m"
CYAN="\e[0;36m"
GREY="\e[0;37m"
RESET="\e[0m"

error()
{
  \echo -e "${RED}$2${RESET}"
  \exit $1
}

warn()
{
  \echo -e "${YELLOW}$1${RESET}"
}

locate_path()
{
  local DIR="$1"

  if [ -L "${DIR}" ]; then
    while [ -L "${DIR}" ]; do
      DIR="$(\cd "$(\dirname -- "$(\readlink -- "${DIR}")")" && \pwd)"
    done
  else
    DIR="$(\cd -P -- "$(\dirname -- "${DIR}")" && \pwd -P)"
  fi

  \echo "${DIR}"
}

extra_var()
{
  # Remove all data after "=" symbol.
  local name=${1%=*}
  local value=${1#*=}
  local SKIP=false

  # Remove leading "--".
  name=${name#--}
  value=${value#--}

  # List of allowed variables for passing as parameters for "ansible-playbook".
  for ansible_reserved_name in limit tags list-tags; do
    if [ "${name}" == "${ansible_reserved_name}" ]; then
      PARAMS+=" --${name}"
      # Don't allow passing the reserved by Ansible parameter as a variable.
      SKIP=true

      # Since we're not formatting parameters as JSON then we aren't interested
      # in a value for the parameter. It simply can be valueless.
      if [ "${name}" != "${value}" ]; then
        PARAMS+="=${value}"
      fi

      break
    fi
  done

  if ! ${SKIP}; then
    if [[ "${name}" == "${value}" || "" == "${value}" ]]; then
      value="true"
    fi

    # Replace all "-" by "_" in argument name.
    name=${name//-/_}

    # Prevent "-1: substring expression < 0" on MacOS 10.12 and some Linux.
    local cf="${value:0:1}"
    local cl="${value:0:${#value}-1}"

    # Allow to pass JSON and arrays as is.
    if [[ "${cf}" != "{" && "${cl}" != "}" ]] && [[ "${cf}" != "[" && "${cl}" != "]" ]]; then
      value="\"${value}\""
    fi

    VARS+="\"${name}\":${value},"
  fi
}

match_file()
{
  for file in "$@"; do
    if [ -f "${file}" ]; then
      \echo "${file}"
      \exit 0
    fi
  done

  \exit 1
}

is_project_root()
{
  [[ -f "$1/.cikit/config.yml" && -f "$1/.cikit/inventory" ]]
}

# ------------------------------------------------------------------------------
# RUNTIME
# ------------------------------------------------------------------------------

# Inside of VM we will not have any host-related commands available so
# via this variable we change the directory for tasks seeking.
if [ -n "${CIKIT_PROJECT_DIR}" ]; then
  TARGET_DIR="${CIKIT_PROJECT_DIR}"
  INSIDE_PROJECT=true
else
  # The directory where the user at the moment.
  TARGET_DIR="$(\pwd)"
  INSIDE_PROJECT=false
fi

# Compute a path to this script and get back from "bash" directory.
\cd "$(locate_path "$0")/../"
# Set the path to CIKit catalog.
SELF_DIR="$(\pwd)"
CIKIT_DIR="${TARGET_DIR}/.cikit"

if ${INSIDE_PROJECT}; then
  SCRIPTS_DIR="${TARGET_DIR}"
else
  SCRIPTS_DIR="${SELF_DIR}"
fi

SCRIPTS_DIR+="/scripts"

if [ -z "$1" ]; then
  if [ -d "${SCRIPTS_DIR}" ]; then
    TASKS=""

    for TASK in "${SCRIPTS_DIR}"/*.yml; do
      TASKS+="$(\basename "${TASK%.*}") "
    done

    # Add the specific task for non-virtualized environment.
    # @todo Add a scanner for tasks from "matrix/" directory.
    if ! ${INSIDE_PROJECT}; then
      TASKS+="matrix/matrix"
    fi

    \echo "${TASKS}"
    \exit 0
  else
    error 13 "The \"${SCRIPTS_DIR}\" directory with CIKit tasks does not exist."
  fi
elif [ "-v" == "$1" ]; then
  \echo "${VERSION}"
  \exit 0
fi

PLAYBOOK="${1/%.yml/}.yml"
PLAYBOOK=$(match_file "${SCRIPTS_DIR}/${PLAYBOOK}" "${SELF_DIR}/${PLAYBOOK}" "${PLAYBOOK}")

if [ $? -gt 0 ]; then
  error 12 "The \"$1\" command is not available."
fi

if \grep -qo "^# requires-project-root$" "${PLAYBOOK}" && ! is_project_root "${TARGET_DIR}"; then
  error 34 "Execution of the \"$1\" is available only within the CIKit-project directory."
fi

# Check whether playbook has declared mandatory options via "# ro:OPTION" annotation.
# If one of the required options is missing, then continuation will be stopped.
while IFS= read -r mandatory_option; do
  required_option_passed=false

  for option in $(IFS="--" \echo "$@"); do
    if [[ "${option}" =~ --${mandatory_option}=.{2,} ]]; then
      required_option_passed=true
      break
    fi
  done

  if ! ${required_option_passed}; then
    error 44 "The \"--${mandatory_option}\" option is required for the \"${1}\" command and currently missing or has a value less than 2 symbols."
  fi
done < <(\awk -F ':' '/^# ro:.+?$/ {print $2}' "${PLAYBOOK}")

# See "provisioner.rb" to get know when it creates.
ENV_CONFIG="${CIKIT_DIR}/environment.yml"

if [ -f "${ENV_CONFIG}" ]; then
  # It's interesting trick with detecting Python interpreter. Sometimes it may differ. Especially
  # on MacOS, when Ansible installed via Homebrew. For instance, "which python" returns
  # the "/usr/local/Cellar/python/2.7.13/Frameworks/Python.framework/Versions/2.7/bin/python2.7",
  # but this particular setup may not have necessary packages for full Ansible operability. Since
  # Ansible - is a Python scripts, they must have a shadebag line with path to interpreter they
  # should run by. Grab it and try!
  # Given:
  #   $(realpath $(which python)) -c 'import yaml'
  # Ends by:
  #   Traceback (most recent call last):
  #     File "<string>", line 1, in <module>
  #   ImportError: No module named yaml
  # But:
  #   $(cat $(which "ansible-playbook") | head -n1 | tr -d '#!') -c 'import yaml'
  # Just works.
  PYTHON_INTERPRETER=$(\head -n1 < "$(\which "${COMMAND}")" | \tr -d '#!')

  if [ -x "${PYTHON_INTERPRETER}" ]; then
    VARS=$("${PYTHON_INTERPRETER}" -c "exec(\"import yaml,json\nprint json.dumps(yaml.load(open('${ENV_CONFIG}')))\")")
    VARS="${VARS##\{}"
    VARS="${VARS%%\}},"
  else
    warn "WARNING: Cannot read environment configuration from \"${ENV_CONFIG}\". Looks like Python setup cannot provide Ansible operability."
  fi
fi

# If the "EXTRA_VARS" passed as environment variable then parse it first to
# not allow overwrite explicitly passed options.
if [ -n "${EXTRA_VARS}" ]; then
  for var in $(IFS="--" \echo "${EXTRA_VARS}"); do
    extra_var "${var}"
  done
fi

# The first argument always treated as a CIKit command. All others are parameters.
for ((i = 2; i <= $#; i++)); do
  extra_var "${!i}"
done

# Remove last comma.
VARS=${VARS%%,}

# Pass any extra arguments for "ansible-playbook". Most useful
# case: "ANSIBLE_ARGS=-vvvv cikit reinstall"
if [ -n "${ANSIBLE_ARGS}" ]; then
  PARAMS+=" ${ANSIBLE_ARGS}"
fi

if [ -z "${ANSIBLE_INVENTORY}" ]; then
  # Attach the inventory only when "-i localhost," is not specified.
  if [[ ! "${PARAMS}" =~ localhost, ]]; then
    INVENTORY=$(match_file "${CIKIT_DIR}/inventory")

    if [ $? -eq 0 ]; then
      # Move "inventory" into user's home directory because it is not mounted file
      # system and can be affected via Linux commands (chmod, chown) under Windows.
      \cp "${INVENTORY}" ~/.cikit-inventory
      \chmod a-x ~/.cikit-inventory
      PARAMS+=" -i ~/.cikit-inventory"
    fi
  fi
# The "uname -o" cannot be used due to "-o" option is not supported on OS X.
elif [[ "$(\uname -s)" =~ "CYGWIN" ]]; then
  ANSIBLE_INVENTORY=$(\cygpath "${ANSIBLE_INVENTORY}")
fi

if [ -n "${VARS}" ]; then
  PARAMS+=" -e '{${VARS}}'"
fi

PARAMS+=" -e __targetdir__='${TARGET_DIR}'"

# https://github.com/sclorg/s2i-python-container/pull/169
export PYTHONUNBUFFERED=1
# https://github.com/ansible/ansible/blob/devel/lib/ansible/config/data/config.yml
export ANSIBLE_ROLES_PATH="${CIKIT_DIR}/roles"
export ANSIBLE_FORCE_COLOR=1
export DISPLAY_SKIPPED_HOSTS=0
export ANSIBLE_RETRY_FILES_ENABLED=0

COMMAND+=" ${PLAYBOOK} ${PARAMS}"

# Print entire command if verbosity requested.
if [[ "${PARAMS}" =~ -v{1,}[[:space:]] ]]; then
  \echo "${COMMAND}"
fi

time eval "${COMMAND}"
